#include <iostream>
#include <stack>
using namespace std;

class Node {
    int data;
    Node *left, *right;

    Node() {
        data = 0;
        left = right = nullptr;
    }

    Node(int d) {
        data = d;
        left = right = nullptr;
    }

    friend class BST;
};

class BST {
    Node *root = nullptr;

    int height(Node *node) {
        if (node == nullptr)
            return 0;

        int l = height(node->left);
        int r = height(node->right);

        return max(l, r) + 1;
    }

    void swapAllNodes(Node *node) {
        if (node == nullptr)
            return;

        Node *temp = node->left;
        node->left = node->right;
        node->right = temp;

        swapAllNodes(node->left);
        swapAllNodes(node->right);
    }

    void inorder(Node *node) {
        if (node == nullptr)
            return;
        inorder(node->left);
        cout << node->data << " ";
        inorder(node->right);
    }

    Node* minValueNode(Node *node) {
        Node *curr = node;
        while (curr && curr->left != nullptr)
            curr = curr->left;
        return curr;
    }

public:
    void insert(int d) {
        Node *curr = root, *prev = nullptr;

        if (curr == nullptr) {
            root = new Node(d);
            return;
        }

        while (curr != nullptr) {
            prev = curr;
            if (d > curr->data)
                curr = curr->right;
            else if (d < curr->data)
                curr = curr->left;
            else {
                cout << "Node already exists." << endl;
                return;
            }
        }

        Node *temp = new Node(d);
        if (d > prev->data)
            prev->right = temp;
        else
            prev->left = temp;
    }

    void search(int d) {
        Node *curr = root;
        while (curr != nullptr) {
            if (d > curr->data)
                curr = curr->right;
            else if (d < curr->data)
                curr = curr->left;
            else {
                cout << "Node found." << endl;
                return;
            }
        }
        cout << "Node does not exist." << endl;
    }

    void getHeight() {
        cout << "Number of nodes in the longest path from root: " << height(root) + 1 << endl;
    }

    void getMinValue() {
        if (root == nullptr)
            cout << "Tree is empty." << endl;
        else
            cout << "Minimum value in the tree: " << minValueNode(root)->data << endl;
    }

    void getAscending() {
        cout << "Values in ascending order: ";
        inorder(root);
        cout << endl;
    }

    void printSwapped() {
        swapAllNodes(root);
        cout << "Tree swapped (left-right pointers at every node)." << endl;
    }
};

int main() {
    BST tree;
    int choice, value;

    while (true) {
        cout << "\n----- MENU -----\n";
        cout << "1. Insert new node\n";
        cout << "2. Find number of nodes in longest path from root\n";
        cout << "3. Find minimum data value in tree\n";
        cout << "4. Swap left and right pointers at every node\n";
        cout << "5. Search a value\n";
        cout << "6. Display tree in ascending order\n";
        cout << "0. Exit\n";
        cout << "Enter your choice: ";
        cin >> choice;

        switch (choice) {
        case 1:
            cout << "Enter value to insert: ";
            cin >> value;
            tree.insert(value);
            break;
        case 2:
            tree.getHeight();
            break;
        case 3:
            tree.getMinValue();
            break;
        case 4:
            tree.printSwapped();
            break;
        case 5:
            cout << "Enter value to search: ";
            cin >> value;
            tree.search(value);
            break;
        case 6:
            tree.getAscending();
            break;
        case 0:
            cout << "Exiting program." << endl;
            return 0;
        default:
            cout << "Invalid choice. Try again." << endl;
        }
    }

    return 0;
}
